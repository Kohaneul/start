#day 11
this
===>교과서적인 의미는
	현재 실행중인 객체의 주소를 기억하는 약속된 변수이다.
	
	이 것은 JVM이 클래스 처리하기 위해서 JVM이 사용하는 변수
	즉, 개발자는 거의 이 변수를 사용하지 않는다.
	
	규칙 ]
		1. 모든 멤버는 사용할 때 반드시 앞에 주소가 있어야 한다.
		   멤버는 클래스 안에 만들어진 변수나 함수를 이야기 한다
		   
		   따라서 new 를 시킨 후 그 주소를 기억해 놨다가
		   그 주소를 이용해서 사용하는 것이다.
		   
		2. 만약 주소가 없으면 JVM이 자동적으로 this를 붙여준다.
		   
		3. 멤버 함수를 호출할 때는 무조건 주소값을 함수한테 알려주도록 약속되어있고
		   함수는 this 변수를 준비한 후 함수를 호출할 때 알려준 주소를 기억하게 된다.
		
		
		
	참고 ] 
		딱 한번 개발자가 this를 사용해야 하는 경우가 있는데, 
		
		가끔은 지역변수와 멤버변수 이름이 동일하게 만들어지는 경우가 있다.
		이러면 그 함수는 지역변수를 우선적으로 사용하게 된다.(가까운 변수를 쓰게 되기 때문)
		따라서 멤버변수(전역변수)에는 데이터가 기억되지 않을 수 있다.
		
		*
		이떄 
		굳이 이 변수가 멤버변수임을 
		반드시 밝혀야 되는 경우가 생기면 
		이때 강제로 this 라고 써주면 된다.



===================================================================================================================================================================

속성
	static 속성
	===> static 영역에 생기는 함수나 변수에 붙여주는 속성
	
		참고 ] 
			클래스, 함수, 변수를 만들때 속성을 지정할 수 있다.
		
		예 ]
			접근지정자	(속성)	class 클래스이름{}
			접근지정자	(속성)	반환값타입	함수이름(매개변수리스트){}
			접근지정자	(속성)	데이터타입	변수이름;
			
			***
			static 영역의 특징
			 	1. 프로그램이 실행되기 위해서 JVM이 로딩되는 순간 저절로 생기는 영역이다.
			 		즉, 사용자가 특별히 만들어달라고 요구하지 않아도 자동적으로 생김.
			 	***	
			 	2. 한번 생긴 변수나 함수는 두번다시 생기지 않는다.
			 	3. 	
			 	
			 static 변수
			 ==> static 영역에 만들어지는 변수
			 
			 형식 ] 
			 	접근지정자	static	(속성)	데이터타입	변수이름;
			 	ex) public static final int BLACK = 100; (=>상수)		
			 	
			 특징 ] 
			 	1. 여러 오브젝트(객체)가 공동으로 사용하는 변수
			 		왜??
			 		객체를 100개 만들어도 static 영역에 한번만 올려지기 때문이다.
			 	 	따라서 한 오브젝트가 데이터를 바꾸면 다른 오브젝트들도 바뀐 데이터를 사용해야 한다.
			 	 	
			 	 	따라서 결국 static 변수는 오브젝트의 의미가 없다.
			 	 	그리고 오브젝트가 없어도 사용할수 있다.
			 	 2. new 시키지 않아도 사용할 수 있는 변수
			 	 	왜?
			 	 		이미 static 영역에 올려져 있기 때문..
			 	 	결론적으로
			 	 		사용방법
			 	 			클래스이름.변수이름;
			 	 			클래스이름.함수이름(데이터);

		
		
###############################################################################################################################################		
		*****
		static 멤버에는 this를 붙일 수 없다.
		this ==> new 시켜서 heap에 만들어진걸 기억하는것
		static 멤버는 Heap 아닌 static 영역에 기억되기 때문
		
###############################################################################################################################################		
	
		static 함수
		===> static 변수와 마찬가지로 static 영역에 올려지는 함수
			 따라서 객체를 만들지 않아도 사용할 수 있는 함수
			 
			사용방법]
				클래스이름.함수이름();
			특징 ] 
			==> this를 사용할 수 없는 함수
			
		**
		결론 ] 
			static 함수 안에서는 메모리에 올려진 것들만 사용할 수 있다.
			일반함수 안에서는 static 멤버 일반 멤버도 사용 가능하다.


--------------------------------------------------------------------------------------------------------------------------------------------------
멤버변수의 초기화			
===> 멤버변수는 Heap 영역에 생기므로 자동 초기화가 된다.
	 하지만 가끔은 변수에 기본적인 값을 지정할 필요가 있다.
	 
	 1. 명시적 초기화
	 	===> 변수를 선언하면서 값을 대입하는 것
			 가장 먼저 실행되는 방법
			 
			 예 ]
			 	class Test{
			 		int no = 10 ==> 명시적 초기화;
			 	}	 	
	 2. 초기화 블럭을 이용한 초기화
			==> 이것은 인스턴수 변수에 한해서만 가능한 방법으로 
				두번째로 실행되는 방법
				
				방법 ] 
					{
						이 안에서 데이터를 변수에 입력;
					}	
					
	 3. static 블럭을 이용한 초기화
	 	===> 위의 2번과 마찬가지로 static 변수에 한해서만 가능한 방법
	 		 두번째로 실행되는 방법
	 		 
	 		 형식 ] 		
	 			static {	//==>static 초기화 블록
	 				데이터입력
	 			}	
	 		예 ]
	 			class Test{
	 				static int no;
	 				static {no = 100;}
	 			}
	 			
	 4. 생성자를 이용한 초기화 		
		===> 가장 마지막에 실행되는 방법
		
			예 ] 
				class Test{
					int no;
					public Test(){
						no = 100; //생성자를 이용한 초기화
					}
					
					
				}	 	
			
=============================================================================================================================================
객체지향 언어의 특징
	1. 상속
	2. 다형성
	3. 은닉화 / 캡슐화
=============================================================================================================================================

상속 ] 
	====> 이미 만들어진 클래스의 기능을 그대로 부여받아서
		  (변수와 함수의 기능을 그대로 복사해 와서)
		   새로운 클래스를 만드는 방법
			
		  소프트웨어 개발 속도를 빠르게 하기 위한 방법의 한가지..
		  
		  즉, 상속은 객체지향에서 매우 중요한 첫번째 역할을 하는것으로
		  객체 지향 언어는 부품 단위(클래스)로 프로그램을 만든 후
		  그 부품을 조립해서 원하는 결과를 얻어내는 것
		  
		  어딘가에서 부품(클래스)을 구했는데 
		  그 기능이 사용자 마음에 들지 않을 수 있다. 
		  이때 처음부터 다시 만들어야 하나?? 라는 문제에서
		  이 문제를 해결하기 위해 만들어진 방법이 상속이다.
		  
		  상속은 자신이 만들고자 하는 부품과 가장 유사한 부품을 가지고 와서 
		  일단 그 기능을 다 복사한 후 
		  	
		  	1. 없는 기능은 더하고
		  	2. 수정할 기능은 수정하고
		  
		  상속하는 형식 ] 
		  	접근지정자 [속성] class 클래스이름 extends 복사해 올 클래스이름{
		  	}
		  	
		  ***
		  참고 ]
		  	자바는 오직 단일 상속만 가능하다(여러클래스에서 동시에 상속X)
		  	extends 뒤에는 오직 한 클래스만...
		  	
		  	즉, 상속은 오직 한개의 클래스에서만 받을 수 있다.
		  	예 ] 
		  		class NewClass extends Old1,Old2  <== X
		  		
		  		class NewClass extends Old1 <== O
		  			
		  용어 ] 
		  	상속을 해준 클래스	==> 상위 클래스, Super Class, 부모클래스
		  	상속을 받은 클래스	==> 하위 클래스, Sub Class, 자식클래스
		  	
		  	is a 	==> 상속관계에 있는 클래스를 부르는 용어
		  				class Father {}
		  				class Son extends Father{}
		  				==> father 클래스 안에 있는 것을 son 클래스가 상속받음
		  				==> Son is a Father 가 성립된다.
		  				Father f = new Son();
		  				Son s = (Son)new Father();
		  				
		  				
		  	has a	==> 어떤 클래스 안에 다른 클래스를 멤버로 가지고 있는 상태
		  				class Father{}
		  				class Son{
		  					Father f = new Father();
		  				}
		  				==> Son has a Father 가 성립된다.
		  				

	상속관계에 있는 경우 생성자의 역할
		
		하위클래스가 생성되는 순간 
		상위클래스의 객체가 자동 생성된다.
		==> new + 생성자함수 <--Heap에 만들어짐
			생성되는 순간 생성자 함수가 호출된다.
		  	따라서 하위클래스를 생성하면 
		  	상위클래스의 기본 생성자 함수도 실행된다.			
		
		상위클래스의 생성자함수는 자동 호출된다.
		자동 호출되는 경우 무조건 기본생성자만 이용하게 된다.
		
		
	***
	참고 ] 
		super()
			==> 상위클래스의 특별한 생성자를 강제 호출하는 기능을 가진 명령.
				현재 클래스의 생성자 함수에서 상위클래스의 생성자를 호출하는 유일한 방법
				
			특징 ] 
				1. 반드시 생성자 함수 안에서만 사용해야 한다.
				2. 반드시 첫줄 첫 문장으로만 올 수 있다.
				
				
			예 ] 
				class Father{
					int no;
					public Father(){
						
					}
					public Father(int no){
						this.no = no;
					}
				}
				
				class Son extends Father{
					char ch;
					
					public Son(){}
					public Son(int no , char ch){
						super(no); <== 상위클래스 호출, no가 채워짐
						this.ch = ch; <== char ch는 Son 클래스에 저장하고, int no는 Father 클래스에 넣어라.
					}
				
				}	
						  	
		   	
================================================================================================		   

*****	
함수의 오버라이딩(Overriding : 함수의 재정의 ) 오버로딩 : 똑같은 함수를 겹쳐씀
===> 상속관계에 있는 하위클래스에서 상위클래스가 물려준 함수의 기능을 수정하는 행위
	 상위클래스가 가지고 있는 함수의 기능을 수정하는것
	 
	 
	 방법 ] 
	 	0. 상위클래스에 함수가 존재해야 한다.
	 	1. 상위클래스가 가진 함수의 원형(Prototype)과 동일한 원형으로 만들어야 한다.
	 	
	 		참고 ] 
	 			함수의 원형(Prototype)
	 				반환값 + 함수이름 + 매개변수리스트
	 			
	 	2. 접근지정자는 같거나 넓은 방향으로 작성한다.(default, protected, public)
	 	3. 예외처리는 같거나 좁은 방향으로...(이후 다시 설명...)	
	 		
	 오버라이딩을 하면 
	 내부적으로 super의 함수가 숨겨지고 재정의한 함수가 사용된다. 	
	 public void abc(){}	<==상위클래스
	 
	 public void abc(){		<==하위클래스
	 System.out.println("만세!");}
	 
	 이 경우 
	 상위클래스의 abc함수 호출하는 방법
	 	super.abc(); : 상속해준 클래스의 함수가 호출된다.
	 	abc();	
	 
	 super
		==> this가 현재 실행중인 객체 자기자신을 기억하는 예약된 변수이듯이
			super 역시 예약된 변수 중 하나이다.
			자신의 상위 클래스의 객체 주소를 기억하는 변수이다.
			(상위클래스 멤버를 접근할 수 있을때 사용)
			
			사용목적 ] 
				반드시 소속을 밝혀야 하는 경우가 생길떄 사용한다.
				
========================================================================================================================================================

Object 클래스				
	==> 자바로 만들어진 클래스들의 모든 클래스들의 최상위 클래스 역할을 하는 클래스
	하위클래스는 상위클래스들보다 멤버가 같거나 많다.
	따라서 java로 만들어진 모든 클래스는 Object가 제공하는 모든 기능을(멤버 : 변수,함수)을 자동적으로 사용할 수 있게 된다. 
	
	
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++	
	public class Abc() (extends Object 생략)
	Object o = new Abc();  ==> 다형성
	넓은범위 = 좁은범위 <== 자동형변환 가능
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++	
	
	참고 ] 
		최상위 클래스를 만들어 놓은 이유
			계층추적을 원할하게 하기 위한 조치
			즉, 각각의 클래스의 족보를 정확하게 따질 수 있도록 하기 위해서..
			
	
	참고 ] 
		자바로 만든 모든 클래스는 반드시 상위 클래스를 가지고 있다.
		우리가 지금까지 만든 클래스들도 상위클래스를 가지고 있다.
		만약 강제로 상위 클래스를 지정하지 않으면(-> "extends 클래스이름" 이라고 붙이지 않으면 ) 	
		암묵적으로 Object라는 클래스를 상속받아서 만들어진다.
	
	**
	instanceof
	==>특정 클래스를 new 시키면 주소가 만들어지는데 
	   이 주소가 어떤 클래스 소속의 주소인지를 알아내는 연산자
	   연산의 결과는 true or false로 만들어진다.
	   
	   형식 ] 
	   		주소	instanceof		클래스이름
	   	
	   	의미 ] 
	   		주소가 가리키는 내용이 
	   		지정한 클래스 소속인지를 물어보는 것	   		
	   		(주소가 클래스 이름의 인스턴스냐?)	
			   
	   	참고 ] 
	   		소속이라는 개념은 is a 관계를 따지는 것이다.
	   		상속 관계는 따지는 개념이 소속이라는 것이다.
	   		
===================================================================================================================================

package와 import
	package 란?
	==> 자바 프로그램(소스코드)가 들어있는 폴더를 
		java에서 부르는 용어
		
		자바는 오픈소스이다.
		모든 사람이 자신이 만든 프로그램을 제공할 수 있고 
		그것을 모든 사람이 이용할 수 있다.
		
		그러다보니 문제점이 발생했는데,
			클래스 이름이 충돌이 날 수 있다.
		이런 문제를 해결하기 위해서 만들어놓은 한가지 방법이 바로 패키지 이다.
		
		즉, 소스를 만드는 사람이 그 프로그램이 포함되는 폴더이름까지 정해서 프로그램을 만들도록 하는것.
		
		결론적으로 
		자바로 프로그램을 만들때는 반드시 이프로그램이 어떤 폴더에 저장되는지를 알려주도록 해놓았다.
		
		명령 ] 
			package		폴더이름;
			
		참고 ] 
			패키지 이름을 만드는 권장사항은
			자신이 사용하는 도메인을 거꾸로 쓴 후 그 다음에 다시 폴더이름을 붙여서 만들어준다.
			이때 경로의 구분자는 /를 쓰는 것이 아니고
			자바에서는 .으로 구분해서 처리한다.
			
			예 ] 
				githrd.com
				
				==>com.githrd.t0310
		
				
	   import란?	 
	   ==> 자신이 사용할 클래스가 어느 폴더(패키지)에 있는 클래스를 사용할 것인지를 밝혀주기 위한 명령
	   		
	   		예 ] 
	   			내가 
	   				Sample.Test.class
	   			유나
	   				yuna.Test.class
	   				
	   	==> 유나씨가 프로그램을 사용하고 싶다. 
	   	import yuna.Test;
	   	
	   	==> 내가 만든 Test를 사용하고 싶다.
	   	import Sample.Test;
		
		형식 1 ]
			
			import 패키지경로.클래스이름;
			==> 지정한 폴더의 지정한 클래스를 사용할 예정임을 밝힘.
			
		형식 2 ]
		
			import 패키지경로.*;
			==> 지정한 경로에 있는 모든 클래스 중 일부를 사용할 예정임을 밝힘. 
			
			주의 ] 
				
				t1 -------- s1
						|
						|-- s2 ------ Test1.java
						|			|
						|			|- Test2.java
						| 			|- Teset3.java
						|
						|
						|
		                |-- Test01.java
						|-- Test02.java	
						
		이 경우
			import t1.*;
			==> Test 01, Test02만 사용할 준비를 하게 된다.
			만약 Test1을 사용하려면
			import t1.s2.*;라고 별도로 임포트 해야한다.
			
			따라서 결론적으로 * 기호를 사용한 import 명령은
			하위의 패키지 내의 클래스까지 사용할 준비를 하는 것이 아니고
			직속 클래스만 사용할 준비하는 것이다.
		
		참고 ] 
			2번보다는 1번을 우선적으로 적용시킨다.	
			
			예 ]
				sample.Test.java
				test.Test.java
	 			
	 			import test.Test;
	 			import sample.*;
	 			 
	 			==> 사용하는 Test 클래스는 test 패키지의 Test 클래스를 사용하게 된다.
	 			
	 	참고 ] 
	 		import 를 하지 않아도 
	 		명시적으로 사용할 수 있는 패키지가 있는데
	 		java.lang 패키지이다.		
	 		왜?? JVM이 기본적으로 찾아보는 패키지 이기 때문. 
	
		---------------------------------------------------------------------------------------
		
		static import
		==> static 멤버는 원칙적으로 
			클래스이름.멤버이름 로 사용해야한다.
			
		참고 ]
			 Math.PI
			 Math.random()
			 
			 이때 static 멤버 앞에 사용하는 클래스 이름조차도 생략할 수 있다.
			 ===> 이처럼 static 멤버를 사용할 때
				  클래스 이름을 생략할 수 있도록 하는 방법이
				  static import이다.
				  
			 형식 ] 
				import static 패키지경로.클래스이름.*;
				
				random() ==> Math 클래스의 random() 함수를 호출하게 된다.
				
				
	----------------------------------------------------------------------------------------------
	
	final 속성
	 1. final 변수
	 	==> 이 변수는 값을 수정할 수 없는 변수이디ㅏ.
	 		 즉, 현재 값을 유지해야만 하는 변수
	   		  <== 서언과 동시에 초기화를 하는 것이 일반적.
				
	
	2. final 함수
		==> 이 함수는 오버라이드(함수의 재정의)가 불가능한 함수가 된다.
			따라서 이 함수는 매우 중요한 함수이므로
			함부로 기능을 바꾸지 말고 현재 기능 그대로 사용하세요.
	
	3. final 클래스
		==>	이 클래스는 더이상 상속이 불가능한 클래스임을 밝히는 속성
			기능을 추가 혹은 변경하지 말고
			현재기능 그대로 이용하라는 의미
			
==================================================================================================================

	상위클래스의 타입 변수로 하위 클래스의 인스턴스를 기억하는 경우,
	변수는 레퍼런스 쪽을 따르고 
	함수는 인스턴스쪽으르 따른다. 상속관계 있는 경우 맨 마지막 오버라이드 한 클래스로 
	인스턴스쪽에서 수정한 내용대로 실행한다..........
	단, 래퍼런스 쪽에 실행하려는 함수가 존재해야한다.
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			 
	
	
									 		   