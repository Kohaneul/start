# day08

배열의 복사
	종료 ] 
		1. 얕은 복사
			==> 주소만 복사하는 방법
			
			특징 ] 
				데이터는 공유하기 떄문에
				한곳에서 수정하면 다른 곳에서도 수정된 내용을 사용
			
			
			방법 ] 
				int[] a = new int[5];
				....
				
				int[] b;
					이 변수는 배열의 주소를 기억할 변수를 만들어준 결과..
					b 안 데이터는 아직 기억할 수 없고
					오직 같은 Heap 타입의 int[]의 주소만 기억할 수 있다.
					
				b=a ; ==> 얕은 복사가 된다.
				a에서 만든 배열을 같이 공유하게 된다.
				
			참고 ]
			블럭안에서 변수생성 => 그 블럭 에서만 사용가능한 지역변수
				얕은 복사는
				지역변수는 그 지역에서만 사용할 수 있으므로 
				다른 지역에서 Heap 영역의 데이터를 사용할 목적으로
				많이 사용되는 방법.
				
				
				
				stack에 변수만 만들어진 상황.. 직접 참고하는 데이터 할당X
				이미 만들어진 A의 주소를 b에 기억시킬 수 있음
				b = a;
				
				
					
		2. 깊은 복사
			==> 데이터를 복사하는 방법
				
				데이터가 복사되었다는 것은
				Heap 영역에 다른 인스턴스 (new 명령으로 생겨난 결과물)가 만들어졌다는 것이므로
				변수가 기억하는 주소가 달라지게 되므로 
				***
				복사된 데이터는 독립적으로 실행된다.
				
			방법 ] 
				명령을 사용해서 처리하면 된다.
				System.arraycopy(#1, #2, #3, $4, #5);
				#1 - 원본 데이터의 주소 
				#2 - 원본 배열의 복사를 시작할 위치  
				#3 - 복사받을 배열의 주소(변수가 주소를 기억)
				#4 - 복사받을 배열의 시작위치 값
				#5 - 복사받을 데이터의 갯수


				 
--------------------------------------------------------------------------------------------------------------------------------------------

배열의 단점
	1. 한번 배열의 크기를 정하면 크기 조절이 불가능하다.
	
		예) 
			int[] no1 = new int[10];
			.....
			작업을 하다가.. 10개를 더 추가해야 하는 경우
			int[] no2 = new int[20];
			
			데이터 복사
			System.arraycopy(no1,0,no2,0,10);
			
			추가 데이터 입력
			no2[10] = ??;
			no2[11] = ??;


	2. 같은 형태의 데이터만 관리할 수 있다.
		==> 주소는 Heap 타입에 의해서 결정되고 
			Heap 타입이 다르면 사용할 수 없다.
			
			예) 
				int[] a = new int[10]; heap 배열 : int 타입
				float[] b;	heap 배열 : float 타입
				
				b = a <== X


--------------------------------------------------------------------------------------------------------------------------------------------

String 배열
	
	참고 ] 
		String 역시 참조형 타입이다.
		String str = "Hong";
		str에는 데이터 자체의 주소가 기억 되고
		String str = new String("Hong");라고 변수를 만들면
		변수는 Heap에 만들어진 인스턴스의 주소를 기억하고
		인스턴스가 데이터의 주소를 기억한다


--------------------------------------------------------------------------------------------------------------------------------------------
	String 배열 만들기
	
		String[] str ; 변수선언, 데이터를 사용할 준비
		str = new String[5];
		==>데이터 초기화가 안되어있는 상태.
			아직 각 인덱스가 비어있는 상태(데이터가 결정 안되어 있는 상태)
			레퍼런스타입  :그냥 데이터가 만들어놓은 공간만 만들어놓은 상태..	
			(그냥 데이터에 접근하면 에러가 발생..)
		str[0] = "Hong";
		str[1] = "Dooly"
		==> 위 처럼 데이터 공간까지 만들어줘야 한다.
		
		String 배열도 초기화가 가능하다.
		
		String[] names = {"둘리","제니","리사","로사","지수"};

--------------------------------------------------------------------------------------------------------------------------------------------
	참고 ] 
		문자열도 필요에 따라서 char[] 형태로 변환해서 사용할 수 있다.
		
		방법 ] 
			toCharArray();
			
		예 ] 
			String name = "jennie";
			
			char[] ch = name.toCharArray(); ==> 문자배열로 반환
			차근차근 문자로 담아서 반환..
			ch[0] ==>j
			ch[1] ==>j
			
			
		//기본데이터 : 자동으로 정수가 채워짐
		



--------------------------------------------------------------------------------------------------------------------------------------------
	참고 ] 
		String 클래스에서 자주 사용되는 함수
		1. charAt(인덱스)
			==> 해당 위치의 문자를 알려준다.
		2. length()
			==> 문자열의 길이를 알려준다
		3. substring() 문자열 일부만 잘라서 반환(=일부만 꺼내주는 함수)
			==> 문자열 중에서 원하는 문자열만 따로 뽑아서 반환(=내보낸다)
			형식 1] 
				substring(시작위치); : 시작위치에서부터 맨 마지막까지 모두 추출
			
			형식 2]
				substring(시작위치, 종료위치) : 시작위치에서부터 종료위치 이전 문자까지 추출				
				
				** 주의할점]
					시작위치는 0부터 카운트 해서 지정.
					종료위치는 1부터 카운트 해서 지정.
					
		4. equals()
			==> 문자열의 데이터 자체가 같은지 비교해서 논리값으로 반환해주는 함수	


--------------------------------------------------------------------------------------------------------------------------------------------
		
2차원 배열
	==> 1차원 배열을 관리하는 배열
		==>배열안에 다시 배열(정확히는 배열 안에 1차원 배열의 주소만)이 들어있는 형태	

	2차원 배열을 만드는 방법
		1. 배열 주소를 기억할 변수를 만든다.
			==> Heap 영역에 있는 데이터는 주소를 알아야 사용하기 때문
			
			방법 ] 
				데이터타입[][]	변수이름;
				==>[]가 1개이면 1차원 배열
				==>		2개이면 2차원 배열
				==>		3개이면 3차원 배열
				. . . .
				
			예 ]
				int[][] num; 정수를 기억할 배열들을 관리할 배열의 
				num = new int[5] <== X : Heap 타입이 1차원이라 안됨..
				
		2. 1차원 배열을 몇개를 관리할지 결정하고 1차원 배열의 주소를 기억할 메모리를 만든다.
			
			방법 ]
				new 데이터타입[갯수][];
				==> 갯수는 1차원 배열의 갯수와 동일(배열 몇개관리할건지 지정..)
			
			예	]
				num = new int[5][];
				==> 정수 배열을 관리할 방 : 5개
				
				
		3. 실제 정수를 관리하는 1차원 배열의 길이를 결정하고 
			1차원 배열의 주소를 기억할 메모리를 만든다.
			
			방법 ] 
				new	데이터타입[갯수];
			
			예	]
				num[0] = new int[3];
				==>num[0]번째 배열에 3개의 정수형 배열을 집어넣는다..
				
--------------------------------------------------------------------------------------------------------------------------------------------
		
		참고 ] 
			2차원 배열도 사각형 형태의 배열을 만들 수 있다.		
		형식 ] 
			데이어타입[][]	변수 = new 데이터타입[행수→][열수↓];	
		예]                                             
			int[][] num = new int[5][3];							 
			==> 정수 3개를 관리하는 배열 5개의 배열
		주의]
			이해를 돕기 위해서 사각형으로 설명하지만,
			실제로는 별도의 메모리 공간을 차지하는 배열이 만들어지고
			그 배열들을 관리하는 배열이 다시 만들어진다.
	
	참고 ] 
		2차원 배열도 초기화가 가능하다.
		
		방법 ] 
			
			int[] num = {데이터1,데이터2,데이터3,....}; // 데이터 갯수만큼 만들어지고 입력된 데이터로 초기회.
			
			int[][] num = {{1,2},{3,4,5},{6,7,8,9}}; 
			==> 
				여기서도 배열의 갯수를 지정할 수는 없다.
				(입력된 데이터 갯수로 인해서 자동으로 배열 갯수가 지정되기 떄문에)
				
				
	
--------------------------------------------------------------------------------------------------------------------------------------------
	
	


			
			
			
			
			
			
			
			